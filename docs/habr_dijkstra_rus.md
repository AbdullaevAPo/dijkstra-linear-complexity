Приветствую всех и особенно тех кто интересуется задачами дискретной математики и теорией графов.
### Предыстория или как я до такой жизни дошел
Так уж вышло, что ведомый интересом я занимался разработкой сервиса построения тур. маршрутов. Задача состояла в том, чтобы на основании интересующего пользователя города, категорий заведений и временных рамок спланировать оптимальные маршруты. Ну и одной из подзадач было рассчитывать время в пути от одного заведения до другого. Так как я был юн и глуп я решал эту задачу в лоб, алгоритмом Дейкстры, но справедливости ради стоит заметить, что только с ним можно было запустить итерацию из одного узла до тысяч других, кэшировать эти расстояния было не вариантом, заведений больше 10к только в одной Москве, а решения типа манхэттенского расстояния на наших городах не работает от слова совсем.
И так вышло, что проблему производительности в задаче комбинаторики решить удалось, а вот большую часть времени на обработку запроса отъедало поиск незакэшированных путей. Проблема усложнялась тем, что граф дорог Osm в Москве довольно большой (полмиллиона узлов и 1.1 млн дуг).
Не буду рассказывать про все потуги и что на самом деле проблему можно было бы решить обрезанием лишних дуг графа, расскажу лишь про то, что в какой-то момент меня озарило и я понял, что если подойти к алгоритму Дейкстры с точки зрения вероятностного подхода то он может быть линеен.

### Дейкстра за логарифмическое время или то, что я смог найти
  Всем известно, а кому неизвестно почитайте http://e-maxx.ru/algo/dijkstra_sparse, что алгоритм Дейкстры за счет использования очереди с логарифмической сложностью вставки и удаления можно привести к сложности вида O(n*log(n) + m*lon(n)). При использовании фиббоначиевой кучи сложность можно опустить до O(n*lon(n) + m), но все равно не линейно, а хотелось бы.
В общем случае алгоритм с очередью описывается следующим образом:

Пусть:
* V - множество вершин графа
* E - множество ребер графа
* w[i, j] - вес ребра из узла i в узел j
* a - начальная вершина поиска
* q -очередь вершин
* d[i] - расстояние до i-го узла
* d[a] = 0, для всех остальных d[i] = +inf

Пока q не пустой:
* v - вершина с минимальным d[v] из q 
* Для всех вершин u для которых есть переход в E из вершины v 
    * if d[u] > w[vu] + d[v]
        * удалить u из q с расстоянием d[u]
        * d[u] = w[vu] + d[v]
        * добавить u в q с расстоянием d[u]

Если в качестве очереди использовать красно-черное дерево, где вставка и удаление происходят за log(n), а поиск минимального элемента аналогично за log(n), то сложность алгоритма составит O(n*log(n) + m*log(n)).
И тут стоит заметить одну важную особенность: ничего не мешает, в теории, рассмотреть вершину несколько раз. Если вершина была рассмотрена и расстояние до нее было одновленно на некорректное, большее, чем истинное значение, то при условии, что рано или поздно система сойдется и расстояние до u будет обновлено на корректное значение позволительно делать такие трюки. Но стоит заметить - одна вершина должна рассматриваться больше чем 1 раз с некоторой малой вероятностью.
### Сортирующая хэш-таблица
Для сведения времени работы алгоритма Дейкстры к линейному предлагается структура данных, представляющая из себя хэш-таблицу с номерами узлов(node_id) в качестве значений. Замечу, потребность в массиве d никуда не девается, он все так же нужен, что получать расстояние до i-го узла за константное время.  
На рисунке ниже приведен пример работы предлагаемой структуры.

Опишем пошагово предложенную структуру данных:
- узел u записывается в ячейку под номером равным d[u] // bucket_size, где bucket_size  мощность ячейки (к примеру 20 метров, т.е. ячейка под номером 0 будет содержать узлы расстояние до которых будет лежать в диапозоне [0, 20) метров)
- минимальным узлом будет считаться последний узел первой непустой ячейки, т.е. операция извлечения минимального элемента будет выполняться за O(1). Необходимо поддерживать актуальное состояние идентификатора номера первой непустой ячейки (min_el). 
- операция вставки выполняется посредством добавления в конец ячейки нового номера узла и в тоже выполняется за O(1), т.к. вычисление номера ячейки происходит за константное время.
- операция удаления, как в случае с хэш-таблицей, возможен обычный перебор, и можно было бы сделать допущение и сказать, что при малом размере ячейки это тоже O(1). Если вам не жалко памяти (в принципе и не так много нужно, еще один массив на n), то можно завести массив позиций в ячейке. При этом, если удаляется элемент в середине ячейки, необходимо переместить последнее значение в ячейке на удаляемое место.
- важный момент:
- можно также удалять пустые ячейки до min_el, тем самым экономя память.

Тем кто знаком с Java дальнейшее описание будет проще воспринять. Там есть структура данных, называемая LinkedHashMap, которая по сути представляет собой хэш-таблицу, из которой элементы, за счет наличия списка, можно достать в порядке добавления. В нашей же версии, элементы таблицы будут отсортированы по расстоянию до него.











PS 
Про алгоритм Торупа и то, что он решает эту же задачу я знаю, что он ее решает за O(n+m) тоже знаю, но я не смог осилить этот фундаментальный труд за один вечер. По крайней мере, как я понял, там предлагается другой подход.